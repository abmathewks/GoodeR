### FEATURE ENGINEERING FUNCTIONS 


###############################################################################



#' @title AddEngineeredDates
#'
#' @description This function will take raw data and aggregate it by date
#'
#' @author Abraham Mathew
#' @family Feature Engineering
#'
#' @param AGG_TS_DATA The raw dataset that will be aggregated
#' @param DATE_COLUMN The column name containing date value
#' @param ADD_CHRISTMAS Add a feature to identify Christmas
#' @param ADD_NEW_YEAR Add a feature to identify New Years
#' @param ADD_OTHER_HOLIDAY Add a feature to identify Other Holidays
#' @param ADD_COVID_SHOCK  Add a feature to identify the months where Covid was prominent
#' @param DEBUG If TRUE, the function will run in debug mode 
#'
#' @return returns a data table with the aggregated data by date and any potential group variables
#' 
#' @export
#' 
AddEngineeredDates <- function(AGG_TS_DATA, 
                               DATE_COLUMN = "date",
                               ADD_CHRISTMAS = TRUE,
                               ADD_NEW_YEAR = TRUE,
                               ADD_OTHER_HOLIDAY = TRUE,
                               ADD_COVID_SHOCK = TRUE,
                               DEBUG = TRUE){
  
    if(DEBUG) message("AddEngineeredDates: Function Initialized  \n")
    
    if(!data.table::is.data.table(AGG_TS_DATA)){
         stop("AddEngineeredDates: The input data is not a data table  \n")
    }
  
    if(!class(AGG_TS_DATA[[DATE_COLUMN]]) %chin% c("Date")) {
         stop("AddEngineeredDates: The date column is not saved in date format  \n")
    }
    
    FUNCTION_OUTPUT <- list()
    
    FUNCTION_OUTPUT[["DATE_COLUMN"]] <- DATE_COLUMN
    FUNCTION_OUTPUT[["ORIGINAL_DATA"]] <- AGG_TS_DATA
    
    AGG_TS_DATA[, date_ymd := lubridate::ymd(get(DATE_COLUMN))]
    
    AGG_TS_DATA[, date_year := data.table::year(date_ymd)]
    AGG_TS_DATA[, date_quarter := data.table::quarter(date_ymd)]
    AGG_TS_DATA[, date_month := data.table::month(date_ymd)]
    AGG_TS_DATA[, date_day := lubridate::day(date_ymd)]
    AGG_TS_DATA[, date_dayofweekname := factor(lubridate::wday(date_ymd, label=TRUE), ordered = FALSE)] 
    AGG_TS_DATA[, is_weekend := fifelse(weekdays(get(DATE_COLUMN)) %in% c("Saturday","Sunday"), 1, 0)]
    
    AGG_TS_DATA[, date_ymd_week := lubridate::floor_date(date_ymd, unit = "week")]
    AGG_TS_DATA[, date_ymd_month := lubridate::floor_date(date_ymd, unit = "month")]

    if(ADD_CHRISTMAS){ 
        AGG_TS_DATA[, is_christmas_day := factor(ifelse( date_month %in% c(12) & date_day %in% c(25), 1, 0 ), ordered = FALSE )]
        AGG_TS_DATA[, is_christmas_around := factor(ifelse( date_month %in% c(12) & date_day %in% c(24,25,26), 1, 0 ), ordered = FALSE)]
    }
    
    if(ADD_NEW_YEAR){ 
        AGG_TS_DATA[, is_newyear_day := factor(ifelse( date_month %in% c(1) & date_day %in% c(1), 1, 0 ), ordered = FALSE )]
        AGG_TS_DATA[, is_newyear_around := factor(ifelse( date_month %in% c(12) & date_day %in% c(31) | 
                                                          date_month %in% c(1) & date_day %in% c(1,2), 1, 0 ), ordered = FALSE)]
    }
    
    if(ADD_OTHER_HOLIDAY){ 
        AGG_TS_DATA[, is_other_holiday_day := factor(ifelse( date_ymd %in% chron::is.holiday(date_ymd), 1, 0 ), ordered = FALSE )]
    }

    if(ADD_COVID_SHOCK){ 
        AGG_TS_DATA[, is_covid_shock := factor(ifelse( date_year %in% c(2020) & date_month %in% c(3:8), 1, 0 ), ordered = FALSE)]
    }
    
    if(DEBUG) message("AddEngineeredDates: Collecting final output  \n")
    
    FUNCTION_OUTPUT[["FINAL_DATA"]] <- AGG_TS_DATA  
      
    if(!is.null(AGG_TS_DATA) || !nrow(AGG_TS_DATA) == 0){
        if(DEBUG) message("AddEngineeredDates: Data acquisition completed  \n")
          
         return(FUNCTION_OUTPUT)
    } else {
       stop("AddEngineeredDates: Function returned an empty data set  \n")
    }
    
} 




    
###############################################################################
  

#' @title CreateTimeSeriesFeatures
#'
#' @description This function will take aggregated time series data and generate various features
#'
#' @author Abraham Mathew
#' @family Feature Engineering
#'
#' @param AGG_TS_DATA The raw dataset that will be aggregated
#' @param DATE_COLUMN The column name containing date value
#' @param WHICH_FEATURES The column names of the original features that we will use
#' @param BY_WHICH_GROUP If value provided, features will be generated by this column
#' @param TIME_UNIT The time frame that is represented in the dataset  (day, week, or month)
#' @param LAG_VALS The numbef of values of the time unit that will be used to create the lagged features
#' @param MA_VALS The numbef of values of the time unit that will be used to create the rolling average features
#' @param SIMPLE_IMPUTE If TRUE, missing values will be imputed with 0.1
#' @param DEBUG If TRUE, the function will run in debug mode 
#'
#' @return returns the originak data table with all the new features appended to the dataset
#' 
#' @export
#' 
CreateTimeSeriesFeatures <- function(
            AGG_TS_DATA,
            DATE_COLUMN = "SalesDate",
            WHICH_FEATURES = NULL,
            BY_WHICH_GROUP = "Currency",
            TIME_UNIT = "day",
            LAG_VALS = c(1:10),
            MA_VALS = c(5:10),
            SIMPLE_IMPUTE = TRUE,
            DEBUG = TRUE){

    if(DEBUG) message("CreateTimeSeriesFeatures: Function Initialized  \n")
    
    if(!is.data.table(AGG_TS_DATA)){
       stop("CreateTimeSeriesFeatures: The input data is not a data table  \n")
    }
  
    if(!class(AGG_TS_DATA[[DATE_COLUMN]]) %chin% c("Date")) {
        stop("CreateTimeSeriesFeatures: The date column is not saved in date format  \n")
    }

    FUNCTION_OUTPUT <- list()
  
    FUNCTION_OUTPUT[["ORIGINAL_DATA"]] <- AGG_TS_DATA

    ALL_FEATURES <- c(WHICH_FEATURES)

    if(is.null(BY_WHICH_GROUP)){ 

        if(DEBUG) message("CreateTimeSeriesFeatures: Creating lagged features  \n")
      
        for(each_var in ALL_FEATURES){
               
             AGG_TS_DATA[, paste0(each_var,TIME_UNIT,"_lag_",LAG_VALS) := shift(get(each_var), 
                                                         n = LAG_VALS, type = "lag")]

            for(each_ma in MA_VALS){ 
          
                if(DEBUG) message("CreateTimeSeriesFeatures: Creating rolling average features  \n")

                 AGG_TS_DATA[, paste0(each_var,TIME_UNIT,"_MA_",each_ma) := lapply(.SD, frollmean, n = each_ma, 
                                                                         fill = NA, align = "left"), .SDcols = each_var]
                 
            }
               
        } 
      
    } else {

        if(DEBUG) message("CreateTimeSeriesFeatures: Creating lagged features by group  \n")     
      
        # each_var = "y"
        for(each_var in ALL_FEATURES){
               
             AGG_TS_DATA[, paste0(each_var,TIME_UNIT,"_lag_",LAG_VALS) := shift(get(each_var), 
                                                         n = LAG_VALS, type = "lag"), by = .(get(BY_WHICH_GROUP))]
            
            for(each_ma in MA_VALS){ 
          
                 if(DEBUG) message("CreateTimeSeriesFeatures: Creating rolling average features  \n")
              
                 AGG_TS_DATA[, paste0(each_var,TIME_UNIT,"_MA_",each_ma) := lapply(.SD, frollmean, n = each_ma, 
                                                                         fill = NA, align = "left"), 
                                                                         by = .(get(BY_WHICH_GROUP)), .SDcols = each_var]
                 
            }
                 
        } 

    }  
  
    if(SIMPLE_IMPUTE){
      
        if(DEBUG) message("CreateTimeSeriesFeatures: Do simpie imputation  \n")
        
        for(j in seq_along(AGG_TS_DATA)){
            set(AGG_TS_DATA, i = which(is.na(AGG_TS_DATA[[j]]) & is.numeric(AGG_TS_DATA[[j]])), j = j, value = 0.1)
        }
      
    }
    
    FUNCTION_OUTPUT[["DATE_COLUMN"]] <- DATE_COLUMN
    FUNCTION_OUTPUT[["WHICH_FEATURES"]] <- WHICH_FEATURES
    FUNCTION_OUTPUT[["BY_WHICH_GROUP"]] <- BY_WHICH_GROUP
    FUNCTION_OUTPUT[["TIME_UNIT"]] <- TIME_UNIT
    FUNCTION_OUTPUT[["LAG_VALS"]] <- LAG_VALS
    FUNCTION_OUTPUT[["MA_VALS"]] <- MA_VALS
    FUNCTION_OUTPUT[["SIMPLE_IMPUTE"]] <- SIMPLE_IMPUTE
    
    if(DEBUG) message("CreateTimeSeriesFeatures: Collecting final output  \n")
    
    FUNCTION_OUTPUT[["FINAL_DATA"]] <- AGG_TS_DATA
  
    if(!is.null(AGG_TS_DATA) || !nrow(AGG_TS_DATA) == 0){
        if(DEBUG) message("CreateTimeSeriesFeatures: Data acquisition completed  \n")
      
         return(FUNCTION_OUTPUT)
    } else {
       stop("CreateTimeSeriesFeatures: Function returned an empty data set  \n")
    }

}



  



###############################################################################


###############################################################################




###############################################################################


###############################################################################





